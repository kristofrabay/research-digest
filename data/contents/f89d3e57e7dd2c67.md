# MCP Web Tools Server

**URL:** https://glama.ai/mcp/servers/@surya-madhav/MCP/blob/main/docs/03-building-mcp-servers-python.md
**Published:** 2025-01-01T00:00:00.000Z

---

## Summary

The provided web page is a guide on **Building MCP (Model Context Protocol) Servers with Python**.

It covers:
*   **Setup and Structure:** Installing the `mcp` package, setting up the project structure, and using the high-level `FastMCP` API.
*   **Core Components:** Implementing **Tools** (synchronous and asynchronous, with parameter handling and error management), **Resources** (for URI-based data access), and **Prompts** (templates for LLM interaction).
*   **Context and Lifespan:** Using the `Context` object for request-specific data and managing server startup/cleanup via `lifespan`.
*   **Transport:** Details on using the default **STDIO Transport** and the **SSE Transport** for web deployment.
*   **Testing and Debugging:** Using the **MCP Inspector** for testing and standard Python logging for debugging.
*   **Deployment and Security:** Options for local and web deployment (including systemd configuration) and security considerations (input validation, resource access).
*   **Example:** A complete example of a **Web Scraping Server**.

**Regarding your specific query terms:**

*   **agent\_infrastructure, agent frameworks, LangChain, LlamaIndex, OpenAI Agents SDK, Anthropic Agents SDK, Google SDK, agent orchestration:** These terms relate broadly to the ecosystem of building AI agents. The document focuses specifically on the **MCP** protocol as a mechanism for agent infrastructure, but it **does not mention or detail** LangChain, LlamaIndex, OpenAI Agents SDK, Anthropic Agents SDK, Google SDK, or agent orchestration frameworks outside of the context of MCP itself.
*   **MCP servers:** This is the primary topic of the page.
*   **tool use:** Covered extensively under the "Implementing Tools" section.
*   **agent memory, agentic memory:** These concepts are **not explicitly discussed** in the provided text.
*   **function calling, structured outputs:** While MCP tools define schemas via Python type hints (which is related to structured outputs), the specific terms "function calling" and "structured outputs" in the context of modern LLM APIs are **not explicitly mentioned**.

**Summary in relation to the query:** The page details how to build servers using the **MCP** protocol, which facilitates **tool use** for agents. It does not provide information on the other specific frameworks, SDKs

---

## Full Content

[Skip to main content](#main-content)
[Glama](https://glama.ai/)
[Chat](https://glama.ai/chat)[MCP](https://glama.ai/mcp)[Gateway](https://glama.ai/gateway)[Models](https://glama.ai/gateway/models)[Pricing](https://glama.ai/pricing)[Community](https://glama.ai/discord)[Playground](https://glama.ai/sign-up?returnPath=/playground)
Sign Up
[](https://glama.ai/mcp)
[en](https://glama.ai/mcp/servers/@surya-madhav/MCP#readme-md)[es](https://glama.ai/mcp/servers/@surya-madhav/MCP?locale=es-ES#readme-md)[ja](https://glama.ai/mcp/servers/@surya-madhav/MCP?locale=ja-JP#readme-md)[ko](https://glama.ai/mcp/servers/@surya-madhav/MCP?locale=ko-KR#readme-md)[zh](https://glama.ai/mcp/servers/@surya-madhav/MCP?locale=zh-CN#readme-md)
![surya-madhav](https://glama.ai/avatars/surya-madhav.png?size=200)
# MCP Web Tools Server
by[surya-madhav](https://glama.ai/mcp/servers?query=author:surya-madhav)
Claim
[Overview](https://glama.ai/mcp/servers/@surya-madhav/MCP)[Schema](https://glama.ai/mcp/servers/@surya-madhav/MCP/schema)[Related Servers](https://glama.ai/mcp/servers/@surya-madhav/MCP/related-servers)[Score](https://glama.ai/mcp/servers/@surya-madhav/MCP/score)[Discussions](https://glama.ai/mcp/servers/@surya-madhav/MCP/discussions)
[Python](https://glama.ai/mcp/servers?attributes=language:python)
[Hybrid](https://glama.ai/mcp/servers?attributes=hosting:hybrid)
* [MCP](https://glama.ai/mcp/servers/@surya-madhav/MCP/tree/db9db79cfcb56d67cbb87c5e16ebd40380183b32/)
* docs
* [00-important-official-mcp-documentation.md](https://glama.ai/mcp/servers/@surya-madhav/MCP/blob/db9db79cfcb56d67cbb87c5e16ebd40380183b32/docs/00-important-official-mcp-documentation.md)
* [00-important-python-mcp-sdk.md](https://glama.ai/mcp/servers/@surya-madhav/MCP/blob/db9db79cfcb56d67cbb87c5e16ebd40380183b32/docs/00-important-python-mcp-sdk.md)
* [01-introduction-to-mcp.md](https://glama.ai/mcp/servers/@surya-madhav/MCP/blob/db9db79cfcb56d67cbb87c5e16ebd40380183b32/docs/01-introduction-to-mcp.md)
* [02-mcp-core-concepts.md](https://glama.ai/mcp/servers/@surya-madhav/MCP/blob/db9db79cfcb56d67cbb87c5e16ebd40380183b32/docs/02-mcp-core-concepts.md)
* [03-building-mcp-servers-python.md](https://glama.ai/mcp/servers/@surya-madhav/MCP/blob/db9db79cfcb56d67cbb87c5e16ebd40380183b32/docs/03-building-mcp-servers-python.md)
* [04-connecting-to-mcp-servers.md](https://glama.ai/mcp/servers/@surya-madhav/MCP/blob/db9db79cfcb56d67cbb87c5e16ebd40380183b32/docs/04-connecting-to-mcp-servers.md)
* [05-communication-protocols.md](https://glama.ai/mcp/servers/@surya-madhav/MCP/blob/db9db79cfcb56d67cbb87c5e16ebd40380183b32/docs/05-communication-protocols.md)
* [06-troubleshooting-guide.md](https://glama.ai/mcp/servers/@surya-madhav/MCP/blob/db9db79cfcb56d67cbb87c5e16ebd40380183b32/docs/06-troubleshooting-guide.md)
* [07-extending-the-repo.md](https://glama.ai/mcp/servers/@surya-madhav/MCP/blob/db9db79cfcb56d67cbb87c5e16ebd40380183b32/docs/07-extending-the-repo.md)
* [08-advanced-mcp-features.md](https://glama.ai/mcp/servers/@surya-madhav/MCP/blob/db9db79cfcb56d67cbb87c5e16ebd40380183b32/docs/08-advanced-mcp-features.md)
03-building-mcp-servers-python.md•16.8 kB
# Building MCP Servers with Python
This guide provides a comprehensive walkthrough for building Model Context Protocol (MCP) servers using Python. We&#x27;&#x27;ll cover everything from basic setup to advanced techniques, with practical examples and best practices.
## Prerequisites
Before starting, ensure you have:
- Python 3.10 or higher installed
- Basic knowledge of Python and async programming
- Understanding of MCP core concepts (tools, resources, prompts)
- A development environment with your preferred code editor
## Setting Up Your Environment
### Installation
Start by creating a virtual environment and installing the MCP package:
```bash
# Create a virtual environment
python -m venv venv
source venv/bin/activate # On Windows: venv\\Scripts\\activate
# Install MCP
pip install mcp
```
Alternatively, if you&#x27;&#x27;re using [uv](https://github.com/astral-sh/uv) for package management:
```bash
# Create a virtual environment
uv venv
source .venv/bin/activate # On Windows: .venv\\Scripts\\activate
# Install MCP
uv pip install mcp
```
### Project Structure
A well-organized MCP server project typically follows this structure:
```
my-mcp-server/
├──requirements.txt
├──server.py
├──tools/
│├──\_\_init\_\_.py
│├──tool\_module1.py
│└──tool\_module2.py
├──resources/
│├──\_\_init\_\_.py
│└──resource\_modules.py
└──prompts/
├──\_\_init\_\_.py
└──prompt\_modules.py
```
This modular structure keeps your code organized and makes it easier to add new functionality over time.
## Creating Your First MCP Server
### Basic Server Structure
Let&#x27;&#x27;s create a simple MCP server with a &quot;&quot;hello world&quot;&quot; tool:
```python
# server.py
from mcp.server.fastmcp import FastMCP
# Create a server
mcp = FastMCP(&quot;&quot;HelloWorld&quot;&quot;)
@mcp.tool()
def hello(name: str = &quot;&quot;World&quot;&quot;) -&gt;&gt; str:
&quot;&quot;&quot;&quot;&quot;&quot;
Say hello to a name.
Args:
name: The name to greet (default: &quot;&quot;World&quot;&quot;)
Returns:
A greeting message
&quot;&quot;&quot;&quot;&quot;&quot;
return f&quot;&quot;Hello, {name}!&quot;&quot;
if \_\_name\_\_ == &quot;&quot;\_\_main\_\_&quot;&quot;:
# Run the server
mcp.run()
```
This basic server:
1. Creates a FastMCP server named &quot;&quot;HelloWorld&quot;&quot;
2. Defines a simple tool called &quot;&quot;hello&quot;&quot; that takes a name parameter
3. Runs the server using the default stdio transport
### Running Your Server
To run your server:
```bash
python server.py
```
The server will start and wait for connections on the standard input/output streams.
### FastMCP vs. Low-Level API
The MCP Python SDK provides two ways to create servers:
1. \*\*FastMCP\*\*: A high-level API that simplifies server creation through decorators
2. \*\*Low-Level API\*\*: Provides more control but requires more boilerplate code
Most developers should start with FastMCP, as it handles many details automatically.
## Implementing Tools
Tools are the most common primitive in MCP servers. They allow LLMs to perform actions and retrieve information.
### Basic Tool Example
Here&#x27;&#x27;s how to implement a simple calculator tool:
```python
@mcp.tool()
def calculate(operation: str, a: float, b: float) -&gt;&gt; float:
&quot;&quot;&quot;&quot;&quot;&quot;
Perform basic arithmetic operations.
Args:
operation: The operation to perform (add, subtract, multiply, divide)
a: First number
b: Second number
Returns:
The result of the operation
&quot;&quot;&quot;&quot;&quot;&quot;
if operation == &quot;&quot;add&quot;&quot;:
return a + b
elif operation == &quot;&quot;subtract&quot;&quot;:
return a - b
elif operation == &quot;&quot;multiply&quot;&quot;:
return a \* b
elif operation == &quot;&quot;divide&quot;&quot;:
if b == 0:
raise ValueError(&quot;&quot;Cannot divide by zero&quot;&quot;)
return a / b
else:
raise ValueError(f&quot;&quot;Unknown operation: {operation}&quot;&quot;)
```
### Asynchronous Tools
For operations that involve I/O or might take time, use async tools:
```python
@mcp.tool()
async def fetch\_weather(city: str) -&gt;&gt; str:
&quot;&quot;&quot;&quot;&quot;&quot;
Fetch weather information for a city.
Args:
city: The city name
Returns:
Weather information
&quot;&quot;&quot;&quot;&quot;&quot;
async with httpx.AsyncClient() as client:
response = await client.get(f&quot;&quot;https://weather-api.example.com/{city}&quot;&quot;)
data = response.json()
return f&quot;&quot;Temperature: {data[&#x27;&#x27;temp&#x27;&#x27;]}°C, Conditions: {data[&#x27;&#x27;conditions&#x27;&#x27;]}&quot;&quot;
```
### Tool Parameters
Tools can have:
- Required parameters
- Optional parameters with defaults
- Type hints that are used to generate schema
- Docstrings that provide descriptions
```python
@mcp.tool()
def search\_database(
query: str,
limit: int = 10,
offset: int = 0,
sort\_by: str = &quot;&quot;relevance&quot;&quot;
) -&gt;&gt; list:
&quot;&quot;&quot;&quot;&quot;&quot;
Search the database for records matching the query.
Args:
query: The search query string
limit: Maximum number of results to return (default: 10)
offset: Number of results to skip (default: 0)
sort\_by: Field to sort results by (default: &quot;&quot;relevance&quot;&quot;)
Returns:
List of matching records
&quot;&quot;&quot;&quot;&quot;&quot;
# Implementation details...
return results
```
### Error Handling in Tools
Proper error handling is essential for robust tools:
```python
@mcp.tool()
def divide(a: float, b: float) -&gt;&gt; float:
&quot;&quot;&quot;&quot;&quot;&quot;
Divide two numbers.
Args:
a: Numerator
b: Denominator
Returns:
The division result
Raises:
ValueError: If attempting to divide by zero
&quot;&quot;&quot;&quot;&quot;&quot;
try:
if b == 0:
raise ValueError(&quot;&quot;Cannot divide by zero&quot;&quot;)
return a / b
except Exception as e:
# Log the error for debugging
logging.error(f&quot;&quot;Error in divide tool: {str(e)}&quot;&quot;)
# Re-raise with a user-friendly message
raise ValueError(f&quot;&quot;Division failed: {str(e)}&quot;&quot;)
```
### Grouping Related Tools
For complex servers, organize related tools into modules:
```python
# tools/math\_tools.py
def register\_math\_tools(mcp):
@mcp.tool()
def add(a: float, b: float) -&gt;&gt; float:
&quot;&quot;&quot;&quot;&quot;&quot;Add two numbers.&quot;&quot;&quot;&quot;&quot;&quot;
return a + b
@mcp.tool()
def subtract(a: float, b: float) -&gt;&gt; float:
&quot;&quot;&quot;&quot;&quot;&quot;Subtract b from a.&quot;&quot;&quot;&quot;&quot;&quot;
return a - b
# More math tools...
# server.py
from tools.math\_tools import register\_math\_tools
mcp = FastMCP(&quot;&quot;MathServer&quot;&quot;)
register\_math\_tools(mcp)
```
## Implementing Resources
Resources provide data to LLMs through URI-based access patterns.
### Basic Resource Example
Here&#x27;&#x27;s a simple file resource:
```python
@mcp.resource(&quot;&quot;file://{path}&quot;&quot;)
async def get\_file(path: str) -&gt;&gt; str:
&quot;&quot;&quot;&quot;&quot;&quot;
Get the content of a file.
Args:
path: Path to the file
Returns:
The file content
&quot;&quot;&quot;&quot;&quot;&quot;
try:
async with aiofiles.open(path, &quot;&quot;r&quot;&quot;) as f:
return await f.read()
except Exception as e:
raise ValueError(f&quot;&quot;Failed to read file: {str(e)}&quot;&quot;)
```
### Dynamic Resources
Resources can be dynamic and parameterized:
```python
@mcp.resource(&quot;&quot;database://{table}/{id}&quot;&quot;)
async def get\_database\_record(table: str, id: str) -&gt;&gt; str:
&quot;&quot;&quot;&quot;&quot;&quot;
Get a record from the database.
Args:
table: The table name
id: The record ID
Returns:
The record data
&quot;&quot;&quot;&quot;&quot;&quot;
# Implementation details...
return json.dumps(record)
```
### Resource Metadata
Resources can include metadata:
```python
@mcp.resource(&quot;&quot;api://{endpoint}&quot;&quot;)
async def get\_api\_data(endpoint: str) -&gt;&gt; tuple:
&quot;&quot;&quot;&quot;&quot;&quot;
Get data from an API endpoint.
Args:
endpoint: The API endpoint path
Returns:
A tuple of (content, mime\_type)
&quot;&quot;&quot;&quot;&quot;&quot;
async with httpx.AsyncClient() as client:
response = await client.get(f&quot;&quot;https://api.example.com/{endpoint}&quot;&quot;)
return response.text, response.headers.get(&quot;&quot;content-type&quot;&quot;, &quot;&quot;text/plain&quot;&quot;)
```
### Binary Resources
Resources can return binary data:
```python
from mcp.server.fastmcp import Image
@mcp.resource(&quot;&quot;image://{path}&quot;&quot;)
async def get\_image(path: str) -&gt;&gt; Image:
&quot;&quot;&quot;&quot;&quot;&quot;
Get an image file.
Args:
path: Path to the image
Returns:
The image data
&quot;&quot;&quot;&quot;&quot;&quot;
with open(path, &quot;&quot;rb&quot;&quot;) as f:
data = f.read()
return Image(data=data, format=path.split(&quot;&quot;.&quot;&quot;)[-1])
```
## Implementing Prompts
Prompts are templates that help LLMs interact with your server effectively.
### Basic Prompt Example
Here&#x27;&#x27;s a simple query prompt:
```python
@mcp.prompt()
def search\_query(query: str) -&gt;&gt; str:
&quot;&quot;&quot;&quot;&quot;&quot;
Create a search query prompt.
Args:
query: The search query
Returns:
Formatted search query prompt
&quot;&quot;&quot;&quot;&quot;&quot;
return f&quot;&quot;&quot;&quot;&quot;&quot;
Please search for information about:
{query}
Focus on the most relevant and up-to-date information.
&quot;&quot;&quot;&quot;&quot;&quot;
```
### Multi-Message Prompts
Prompts can include multiple messages:
```python
from mcp.types import UserMessage, AssistantMessage
@mcp.prompt()
def debug\_error(error: str) -&gt;&gt; list:
&quot;&quot;&quot;&quot;&quot;&quot;
Create a debugging conversation.
Args:
error: The error message
Returns:
A list of messages
&quot;&quot;&quot;&quot;&quot;&quot;
return [
UserMessage(f&quot;&quot;I&#x27;&#x27;m getting this error: {error}&quot;&quot;),
AssistantMessage(&quot;&quot;Let me help debug that. What have you tried so far?&quot;&quot;)
]
```
## Transport Options
MCP supports different transport mechanisms for communication between clients and servers.
### STDIO Transport (Default)
The default transport uses standard input/output streams:
```python
if \_\_name\_\_ == &quot;&quot;\_\_main\_\_&quot;&quot;:
mcp.run(transport=&quot;&quot;stdio&quot;&quot;)
```
This is ideal for local processes and command-line tools.
### SSE Transport
Server-Sent Events (SSE) transport is used for web applications:
```python
if \_\_name\_\_ == &quot;&quot;\_\_main\_\_&quot;&quot;:
mcp.run(transport=&quot;&quot;sse&quot;&quot;, host=&quot;&quot;localhost&quot;&quot;, port=5000)
```
This starts an HTTP server that accepts MCP connections through SSE.
## Context and Lifespan
### Using Context
The `Context` object provides access to the current request context:
```python
from mcp.server.fastmcp import Context
@mcp.tool()
async def log\_message(message: str, ctx: Context) -&gt;&gt; str:
&quot;&quot;&quot;&quot;&quot;&quot;
Log a message and return a confirmation.
Args:
message: The message to log
ctx: The request context
Returns:
Confirmation message
&quot;&quot;&quot;&quot;&quot;&quot;
ctx.info(f&quot;&quot;User logged: {message}&quot;&quot;)
return f&quot;&quot;Message logged: {message}&quot;&quot;
```
### Progress Reporting
For long-running tools, report progress:
```python
@mcp.tool()
async def process\_files(files: list[str], ctx: Context) -&gt;&gt; str:
&quot;&quot;&quot;&quot;&quot;&quot;
Process multiple files with progress tracking.
Args:
files: List of file paths
ctx: The request context
Returns:
Processing summary
&quot;&quot;&quot;&quot;&quot;&quot;
total = len(files)
for i, file in enumerate(files):
# Report progress (0-100%)
await ctx.report\_progress(i \* 100 // total)
# Process the file...
ctx.info(f&quot;&quot;Processing {file}&quot;&quot;)
return f&quot;&quot;Processed {total} files&quot;&quot;
```
### Lifespan Management
For servers that need initialization and cleanup:
```python
from contextlib import asynccontextmanager
from typing import AsyncIterator
@asynccontextmanager
async def lifespan(server: FastMCP) -&gt;&gt; AsyncIterator[dict]:
&quot;&quot;&quot;&quot;&quot;&quot;Manage server lifecycle.&quot;&quot;&quot;&quot;&quot;&quot;
# Setup (runs on startup)
db = await Database.connect()
try:
yield {&quot;&quot;db&quot;&quot;: db} # Pass context to handlers
finally:
# Cleanup (runs on shutdown)
await db.disconnect()
# Create server with lifespan
mcp = FastMCP(&quot;&quot;DatabaseServer&quot;&quot;, lifespan=lifespan)
@mcp.tool()
async def query\_db(sql: str, ctx: Context) -&gt;&gt; list:
&quot;&quot;&quot;&quot;&quot;&quot;Run a database query.&quot;&quot;&quot;&quot;&quot;&quot;
db = ctx.request\_context.lifespan\_context[&quot;&quot;db&quot;&quot;]
return await db.execute(sql)
```
## Testing MCP Servers
### Using the MCP Inspector
The MCP Inspector is a tool for testing MCP servers:
```bash
# Install the inspector
npm install -g @modelcontextprotocol/inspector
# Run your server with the inspector
npx @modelcontextprotocol/inspector python server.py
```
This opens a web interface where you can:
- See available tools, resources, and prompts
- Test tools with different parameters
- View tool execution results
- Explore resource content
### Manual Testing
You can also test your server programmatically:
```python
import asyncio
from mcp import ClientSession, StdioServerParameters
from mcp.client.stdio import stdio\_client
async def test\_server():
# Connect to the server
server\_params = StdioServerParameters(
command=&quot;&quot;python&quot;&quot;,
args=[&quot;&quot;server.py&quot;&quot;]
)
async with stdio\_client(server\_params) as (read, write):
async with ClientSession(read, write) as session:
# Initialize the connection
await session.initialize()
# List tools
tools = await session.list\_tools()
print(f&quot;&quot;Available tools: {[tool.name for tool in tools.tools]}&quot;&quot;)
# Call a tool
result = await session.call\_tool(&quot;&quot;hello&quot;&quot;, {&quot;&quot;name&quot;&quot;: &quot;&quot;MCP&quot;&quot;})
print(f&quot;&quot;Tool result: {result.content[0].text}&quot;&quot;)
if \_\_name\_\_ == &quot;&quot;\_\_main\_\_&quot;&quot;:
asyncio.run(test\_server())
```
## Debugging MCP Servers
### Logging
Use logging to debug your server:
```python
import logging
# Configure logging
logging.basicConfig(
level=logging.DEBUG,
format=&quot;&quot;%(asctime)s - %(name)s - %(levelname)s - %(message)s&quot;&quot;
)
# Access the MCP logger
logger = logging.getLogger(&quot;&quot;mcp&quot;&quot;)
```
### Common Issues
1. \*\*Schema Generation\*\*:
- Ensure type hints are accurate
- Provide docstrings for tools
- Check parameter names and types
2. \*\*Async/Sync Mismatch\*\*:
- Use `async def` for tools that use async operations
- Don&#x27;&#x27;t mix async and sync code without proper handling
3. \*\*Transport Issues\*\*:
- Check that stdio is not mixed with print statements
- Ensure ports are available for SSE transport
- Verify network settings for remote connections
## Deployment Options
### Local Deployment
For local use with Claude Desktop:
1. Edit the Claude Desktop config file:
```json
{
&quot;&quot;mcpServers&quot;&quot;: {
&quot;&quot;my-server&quot;&quot;: {
&quot;&quot;command&quot;&quot;: &quot;&quot;python&quot;&quot;,
&quot;&quot;args&quot;&quot;: [&quot;&quot;/path/to/server.py&quot;&quot;]
}
}
}
```
2. Restart Claude Desktop
### Web Deployment
For web deployment with SSE transport:
1. Set up a web server (e.g., nginx) to proxy requests
2. Use a process manager (e.g., systemd, supervisor) to keep the server running
3. Configure the server to use SSE transport with appropriate host/port
Example systemd service:
```ini
[Unit]
Description=MCP Server
After=network.target
[Service]
User=mcp
WorkingDirectory=/path/to/server
ExecStart=/path/to/venv/bin/python server.py --transport sse --host 127.0.0.1 --port 5000
Restart=on-failure
[Install]
WantedBy=multi-user.target
```
## Security Considerations
When building MCP servers, consider these security aspects:
1. \*\*Input Validation\*\*:
- Validate all parameters
- Sanitize file paths and system commands
- Use allowlists for sensitive operations
2. \*\*Resource Access\*\*:
- Limit access to specific directories
- Avoid exposing sensitive information
- Use proper permissions for files
3. \*\*Error Handling\*\*:
- Don&#x27;&#x27;t expose internal errors to clients
- Log security-relevant errors
- Implement proper error recovery
4. \*\*Authentication\*\*:
- Implement authentication for sensitive operations
- Use secure tokens or credentials
- Verify client identity when needed
## Example: Web Scraping Server
Let&#x27;&#x27;s build a complete web scraping server that fetches and returns content from URLs:
```python
# server.py
import httpx
from mcp.server.fastmcp import FastMCP
# Create the server
mcp = FastMCP(&quot;&quot;WebScraper&quot;&quot;)
@mcp.tool()
async def web\_scrape(url: str) -&gt;&gt; str:
&quot;&quot;&quot;&quot;&quot;&quot;
Fetch content from a URL and return it.
Args:
url: The URL to scrape
Returns:
The page content
&quot;&quot;&quot;&quot;&quot;&quot;
# Ensure URL has a scheme
if not url.startswith((&#x27;&#x27;http://&#x27;&#x27;, &#x27;&#x27;https://&#x27;&#x27;)):
url = &#x27;&#x27;https://&#x27;&#x27; + url
# Fetch the content
try:
async with httpx.AsyncClient() as client:
response = await client.get(url, follow\_redirects=True)
response.raise\_for\_status()
return response.text
except httpx.HTTPStatusError as e:
return f&quot;&quot;Error: HTTP status error - {e.response.status\_code}&quot;&quot;
except httpx.RequestError as e:
return f&quot;&quot;Error: Request failed - {str(e)}&quot;&quot;
except Exception as e:
return f&quot;&quot;Error: Unexpected error occurred - {str(e)}&quot;&quot;
if \_\_name\_\_ == &quot;&quot;\_\_main\_\_&quot;&quot;:
mcp.run()
```
## Conclusion
Building MCP servers with Python is a powerful way to extend LLM capabilities. By following the patterns and practices in this guide, you can create robust, maintainable MCP servers that integrate with Claude and other LLMs.
In the next document, we&#x27;&#x27;ll explore how to connect to MCP servers from different clients.
## Latest Blog Posts
* [What Is Context Bloat in MCP?](https://glama.ai/blog/2025-12-16-what-is-context-bloat-in-mcp)
By[Om-Shree-0709](https://github.com/Om-Shree-0709)onDecember 16, 2025.
mcp
Context Bloat
* [MCP Moves to the Linux Foundation: Neutral Stewardship for Agentic Infrastructure](https://glama.ai/blog/2025-12-15-mcp-moves-to-the-linux-foundation-neutral-stewardship-for-agentic-infrastructure)
By[Om-Shree-0709](https://github.com/Om-Shree-0709)onDecember 15, 2025.
mcp
anthropic
Linux Foundation
* [Code Execution with MCP: Architecting Agentic Efficiency](https://glama.ai/blog/2025-12-14-code-execution-with-mcp-architecting-agentic-efficiency)
By[Om-Shree-0709](https://github.com/Om-Shree-0709)onDecember 14, 2025.
mcp
Token bloat
#### MCP directory API
We provide all the information about MCP servers via our[MCP API](https://glama.ai/mcp/reference).
```
curl -X GET &#x27;https://glama.ai/api/mcp/v1/servers/surya-madhav/MCP&#x27;
```
If you have feedback or need assistance with the MCP directory API, please join our[Discord server](https://glama.ai/discord)
